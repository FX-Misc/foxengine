
#2008-12-10
基本确认以list内含np.array 1d为主
只有在需要用到集合运算时，才以np.array的二维形式，但结果仍然要转换为1d

数据流向

db ==> 2d arrays ==> 1d arrays ==> 普通运算(等长)
   ==>集合运算(指数、排序;来源包括基础数据和计算数据)
   ==> 1d arrays  ==>  普通运算
   ==> (运算结果的)集合运算 ==> 1d arrays

在这里，第一次普通运算是等长序列的运算，第二次普通运算中已经抛掉非交易日

#2009-02-08
#todo: 
#1.优势率
#2.净值衰落 值和周期
#

#2009-02-17
kwargs的妙用，当关键字默认参数和*args并用时，需要用kwargs解决问题。应用场景是类似于dispatch这样的decrator
kwargs的慎用，如果有**kwargs，并且存在有默认值的关键字参数，则会因为拼写错误引入很难测试的隐患
    如 def foo(a,bnext=1,kwargs): ...
    如下调用
        foo(a,bnetx=12)
    并不会检查出这个拼写错误，如果这个参数不是非常敏感的参数或者在复杂情形下，则这类错误非常难以判断

#2009-02-25
#1 筛选思路
1.1 先用相关的cruiser进行巡游，时间段为20010701-20060101
    只有那些在这段时间内仍然能够保持MM优势率>1500-2000的才进入下一步
1.2 进入run过程，对候选就20071001-20090101进行遍历，仍然要求优势率>1500-2000
1.3 对候选就20020101-20090101进行遍历，要求1.2的优势率不降低，即不能在主升段降低优势率
1.4 进行分段ev检验，20010701-20060101,20050701-20070930,20071001-20090101,20010701-20090101

#2009-03-07
#1 进行run_merge
#2 Finished 进行vama2x的第二次巡游
   并整理svama2x和vama2x的巡游结果 
#3 考虑对ma120的强制约束，以及ma分类约束
#4 考虑各选出的算法的实际含义，逐个研究每个算法选出股票的方式方法，细致观察其选出的股票
   用excel来做
#5 Finished 核对600433 20071204买入，次日卖出的原因  
    name:Mediator:<svama2x:ma_standard=20,base=82,fast=1,sma=33,slow=8:atr_seller:covered=10,up_sector=2,trace_times=3000,stop_times=600,buy_sector=0:make_trade_signal_advanced:B1S1>
    消除此类现象
#6 计算板块在上升过程中前三甲的龙头股 > 8500     
#7 transform重大修正之后对受影响不分的重新巡游
   Finshed: svama2,svama3,svama2s,svama2c,svama2x,vama3,vama2,vama2x, 是否逐渐淘汰掉vama系列


#2009-03-12
#诡异
begin,xbegin,end,lbegin = 20060101,20070901,20090327,20081101
name:Mediator:<vama3:ma_standard=500,slow=45,extend_days=17,fast=32,mid=79:atr_seller:up_sector=2,trace_times=3000,stop_times=600,covered=10:make_trade_signal_advanced:B0S0>
应当在第三天退出，但是到0312也没有卖出
SH600370	B	20090224	price=4500	volume=1000
bug已经修正

另
name:Mediator:<vama3:ma_standard=500,slow=50,extend_days=31,fast=30,mid=67:atr_seller:up_sector=2,trace_times=3000,stop_times=600,covered=10:make_trade_signal_advanced:B0S0>
SH600766	B	20081224	price=3490	volume=1000
这个是正确的

#2009-03-14
#1 catalog单项测试
发现一个诡异的现象，渐涨板块中的龙头股(>8500)的表现不如中间股(3300-6600). 
这里的环境是没有加持g的20,60,120,250的持续增长。单项加持c, 这之中又以c60表现最好。

最佳表最先比g的单项加持要好很多，成功率从333->520,R从1025->2700,times从245->67

# g与catalog共同加持，结果导致次数以2个数量级锐减，缺乏实际意义，而且结果也不如单独的c加持
#
#2 另一个重要发现
以19980101为起始日，对vama3的unit计算有重大影响，大大优于20000101. 仅对
fcustom(vama3,fast= 33,mid= 84,slow=345,ma_standard=500,extend_days= 27,dates=dates,cextractor=ext_factory(3300,6600))
而言

#3 检验g60的5和60上叉的效果
基本确定g不能单独作为主要条件，只能做为筛选条件

另对g作筛选时的
g = gand(stock.g5 >= stock.g20,stock.g20 >= stock.g60,stock.g60 >= stock.g120,stock.g120 >= stock.g250)
进行放宽测试，发现删除第一/第二个/第三/第四个都会有问题

但没有测试 g5>g60而绕过g20的情形,只是单纯的删除

#4 考虑对vama3族的筛选方式


#2009-03-16
#1 对行业选择进行调整，从之前的证监会行业调整为行业。证监会行业太过细化
   从新评估已有的数据
    configs.append(config(buyer=fcustom(csvama2,fast= 13,slow=125,rstart= 1000,rend=5000))) 	#3315-252-593-32    #9078/988
    configs.append(config(buyer=fcustom(csvama2,fast=  2,slow=250,rstart=7000,rend=9000))) 	#1625-117-500-22 #3379/792
    configs.append(config(buyer=fcustom(csvama3,fast= 12,mid= 27,slow=250,rstart=5000,rend=8000))) 	#1000-71-473-19
    configs.append(config(buyer=fcustom(csvama3,fast= 12,mid= 27,slow=330,rstart=3000,rend=6000))) 	#5270-195-714-7
    configs.append(config(buyer=fcustom(csvama3,fast= 16,mid= 21,slow=250,rstart=5000,rend=8000))) 	#1061-69-433-30 
    configs.append(config(buyer=fcustom(csvama3,fast= 12,mid= 19,slow=250,rstart=7000,rend=8000))) 	#939-77-538-13
    configs.append(config(buyer=fcustom(csvama3,fast=  8,mid= 21,slow=385,rstart=1500,rend=8000))) 	#688-64-478-23
    configs.append(config(buyer=fcustom(csvama3,fast= 12,mid= 23,slow=250,rstart=5000,rend=8000))) 	#845-60-392-28
    configs.append(config(buyer=fcustom(csvama3,fast= 44,mid= 23,slow=250,rstart=7500,rend=8000))) 	#1049-85-666-3
    configs.append(config(buyer=fcustom(csvama3,fast= 10,mid= 85,slow=250,rstart=5000,rend=8000))) 	#2185-153-333-3
    configs.append(config(buyer=fcustom(csvama2,fast= 37,slow=115,rstart=3000,rend=8000))) 	#2059-138-327-58
    configs.append(config(buyer=fcustom(csvama3,fast= 12,mid= 27,slow=350,rstart=4500,rend=6000))) 	#913-53-375-8
基本上这些数据已经失效,只剩下三个
    configs.append(config(buyer=fcustom(csvama2,fast= 13,slow=125,rstart= 1000,rend=5000))) 	#2268-188-609-41    #9078/988
    configs.append(config(buyer=fcustom(csvama3,fast= 44,mid= 23,slow=250,rstart=7500,rend=8000))) 	#1948-152-500-2 #383/78
    configs.append(config(buyer=fcustom(csvama2,fast= 37,slow=115,rstart=3000,rend=8000))) 	#1202-95-367-68


#2009-03-19
#1 考虑svap/vap的macd的筛选作用
   macd的标的可以是ma(svap,n),而不仅仅是svap,暂定为5

#2 用nmedaitor排除原先在设置atr的downlimit时不考虑B1/B0的买入信号偏移的问题
    该问题导致B1系列下信号日次日高开时止损点离买入点距离为高开值+设定atr,而非设定atr)

#3 观察，发现atr5叉20也是选股器
    且strend(atr20)>0是筛选器,但更加有效的是strend(atr5/atr20),且<1.2,大的趋势向上(不是小向上但大一顶比一顶低)
    但还是有些模棱两可
    

#4 对atr的止损进行细分，划分为1000(1200?)和2000两档


#5  发现psy的信号效果不错
    PSY:COUNT(CLOSE>REF(CLOSE,1),N)/N*100;
    PSYMA:MA(PSY,M);
    N=12,M=6
    当psy,psyma趋势向上且psy上叉时买入
 
    单独成为信号还是能力有限，但是strend(psy12)>0成为筛选器倒是比较有前途

    但筛选器还只能目测，统计上无法做到筛掉有些目测可以去掉的趋势

    找到一个统计学上的过滤器对svama2,fast=  9,slow=1160,630-46-382-251
    a. psy12<300, ==> 1432-96-516-31  但次数消散很多
    b. psy12<500, ==> 1129-61-327-116 成功率还是不行
    c. psy12在500-600之间 ==> 195-9-408-71 属于负分支

    如果以psy不做ma直接过滤，则
    a.  1101-76-521-23
    b.  264-14-291-48
    c.  146-6-375-64
    d. >600,-99/-5/272/77

#2009-03-23
将基金板块纳入到行业
select * from dune_stockcode_catalogs where catalog_id = 286
select * from dune_catalog where subject_id = '其它板块'

288	ETF基金	其它板块
289	LOF基金	其它板块
291	基金板块	其它板块
292	开放基金	其它板块
293	权证板块	其它板块

#发现深圳基金居然没有在里面，找到问题，需要解决
insert into dune_stockcode_catalogs(stockcode_id,catalog_id) 
select id,291,* from dune_stockcode where code like 'SZ18%'

#1 代码添加 
#采用django的方法
cs = CatalogSubject.objects.get(code='HY')
jjbk2 = Catalog(name=u'基金板块A',subject=cs)
jjbk2.save()
szjjs = StockCode.objects.filter(code__startswith='SZ18')
shjjs = StockCode.objects.filter(code__startswith='SH50')
szetfs = StockCode.objects.filter(code__startswith='SZ159')
shetfs = StockCode.objects.filter(code__startswith='SH510')
jjbk2.stocks.add(*szjjs)
jjbk2.stocks.add(*shjjs)
jjbk2.stocks.add(*szetfs)
jjbk2.stocks.add(*shetfs)

#2 数据添加
#原始数据已经位于dune_sdayquote中，故只需要转换

因此，继续处理
ss = [str(stock.code) for stock in jjbk2.stocks.all()]
['SH500001', 'SH500002', 'SH500003', 'SH500005', 'SH500006', 'SH500007', 'SH500008', 'SH500009', 'SH500010', 'SH500011', 'SH500013', 'SH500015', 'SH500016', 'SH500017', 'SH500018', 'SH500019', 'SH500021', 'SH500025', 'SH500028', 'SH500029','SH500035', 'SH500038', 'SH500039', 'SH500056', 'SH500058', 'SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902']
即
('SH500001', 'SH500002', 'SH500003', 'SH500005', 'SH500006', 'SH500007', 'SH500008', 'SH500009', 'SH500010', 'SH500011', 'SH500013', 'SH500015', 'SH500016', 'SH500017', 'SH500018', 'SH500019', 'SH500021', 'SH500025', 'SH500028', 'SH500029','SH500035', 'SH500038', 'SH500039', 'SH500056', 'SH500058', 'SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902')
#去掉上海基金的部分
 ('SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902')
select * from dune_sdayquote where sstock in  ('SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902')
......

insert into dune_xdayquote(tstock_id,tdate,topen,tclose,thigh,tlow,tavg,tvolume,tamount)
select ds.id,tdate,topen,tclose,thigh,tlow,tavg,tvolume,tamount
from dune_sdayquote sq
join dune_stockcode ds on ds.code = sq.sstock
where sq.sstock in  ('SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902')


#3 除权数据
上海基金均已经被除权
select * from dune_powerinfo dp
join dune_stockcode ds on dp.tstock_id = ds.id
where code in  ('SZ184688', 'SZ184689', 'SZ184690', 'SZ184691', 'SZ184692', 'SZ184693', 'SZ184698', 'SZ184699', 'SZ184700', 'SZ184701', 'SZ184703', 'SZ184705', 'SZ184706', 'SZ184712', 'SZ184713', 'SZ184721', 'SZ184722', 'SZ184728', 'SH510050', 'SH510180', 'SH510880', 'SZ159901', 'SZ159902')

直接
python fxjtransfer.py -x


#2009-03-24
#1 psy(67)的ma(22)对ma(67)的死叉，以及psy/22/67的走势背离，都是大盘改变趋势的信号，且都有提前期

#2 vmacd的死叉貌似是一个卖出信号？提前期还可以，优于psy,psy太提前了
   而且vmacd即便延后，延后也有限
   vmacd(6,13,9)对于卖出更好 [为正常参数的一半]


原始的组合
def vmacd(stock,dates):
    t = stock.transaction
    vdiff,vdea = cmacd(t[VOLUME])
    dcross = gand(cross(vdea,vdiff),strend(vdiff)>0,strend(vdea>0))
    g = gand(stock.g5 >= stock.g20,stock.g20 >= stock.g60,stock.g60 >= stock.g120,stock.g120 >= stock.g250)
    linelog(stock.code)
    
    #ma_standard = ma(t[CLOSE],60)
    #trend_ma_standard = strend(ma_standard) > 0    
    return gand(dcross,g)

其效果为
pre_ev:
        评估:总盈亏值=-1162486,交易次数=127921  期望值=-218
                总盈亏率(1/1000)=-1162486,平均盈亏率(1/1000)=-10,盈利交易率(1/10
00)=262
                赢利次数=33633,赢利总值=3211229
                亏损次数=93614,亏损总值=4373715
                平盘次数=674
                闭合交易明细:


加上
    ma_standard = ma(t[CLOSE],60)
    trend_ma_standard = strend(ma_standard) > 0    
条件
pre_ev:
        评估:总盈亏值=-39070,交易次数=3631      期望值=-230
                总盈亏率(1/1000)=-39070,平均盈亏率(1/1000)=-11,盈利交易率(1/1000
)=280
                赢利次数=1020,赢利总值=86434
                亏损次数=2593,亏损总值=125504
                平盘次数=18
                闭合交易明细:

将ma_standard改为120:
pre_ev:
        评估:总盈亏值=-16881,交易次数=2444      期望值=-143
                总盈亏率(1/1000)=-16881,平均盈亏率(1/1000)=-7,盈利交易率(1/1000)
=303
                赢利次数=741,赢利总值=66605
                亏损次数=1693,亏损总值=83486
                平盘次数=10


c_extractor = lambda c,s:gand(c.g5 >= c.g20,c.g20>=c.g60,c.g60>=c.g120,c.g120>=c.g250,s>=3300,s<=6600)

    cs = catalog_signal_cs(stock.c60,c_extractor)
:
pre_ev:
	评估:总盈亏值=5256,交易次数=86	期望值=1173	
		总盈亏率(1/1000)=5256,平均盈亏率(1/1000)=61,盈利交易率(1/1000)=465
		赢利次数=40,赢利总值=7687
		亏损次数=46,亏损总值=2431
		平盘次数=0

改为ma60:
pre_ev:
    评估:总盈亏值=4796,交易次数=116 期望值=911
            总盈亏率(1/1000)=4796,平均盈亏率(1/1000)=41,盈利交易率(1/1000)=405
            赢利次数=47,赢利总值=7967
            亏损次数=69,亏损总值=3171



弱化板块条件,去除范围
#
pre_ev:
        评估:总盈亏值=5725,交易次数=208 期望值=529
                总盈亏率(1/1000)=5725,平均盈亏率(1/1000)=27,盈利交易率(1/1000)=399
                赢利次数=83,赢利总值=12140
                亏损次数=125,亏损总值=6415
                平盘次数=0
                闭合交易明细:



范围改为
c_extractor = lambda c,s:gand(c.g5 >= c.g20,c.g20>=c.g60,c.g60>=c.g120,c.g120>=c.g250,s<=3300)
pre_ev:
        评估:总盈亏值=461,交易次数=34   期望值=361
                总盈亏率(1/1000)=461,平均盈亏率(1/1000)=13,盈利交易率(1/1000)=294
                赢利次数=10,赢利总值=1345
                亏损次数=24,亏损总值=884
                平盘次数=0




#发现问题所在
			stock=SZ184703 盈亏值=519792:,盈亏率(1/1000):515666
				SZ184703	B	20070308	price=1	volume=1000
				SZ184703	S	20070524	price=525	volume=-1000
修改trade的计算函数,去除这类问题



#3 命令行准备脚本

from wolfox.fengine.core.shortcut import *
from wolfox.fengine.normal.funcs import *
from wolfox.fengine.core.d1match import *
from wolfox.fengine.core.d1indicator import cmacd
from wolfox.foxit.base.tutils import linelog
from time import time

import logging
logging.basicConfig(filename="srun_x4c.log",level=logging.DEBUG,format='%(name)s:%(funcName)s:%(lineno)d:%(asctime)s %(levelname)s %(message)s')
begin,xbegin,end = 20000101,20010701,20091231
tbegin = time()
    
dates,sdata,idata,catalogs = prepare_all(begin,end,[],[ref_code])
import psyco
psyco.full()

import wolfox.fengine.normal.srun as srun
srun.prepare_order(sdata.values())
srun.prepare_order(catalogs)
dummy_catalogs('catalog',catalogs)
pman = AdvancedATRPositionManager()
dman = DateManager(begin,end)
myMediator=nmediator_factory(trade_strategy=B1S1,pricer = oo_pricer)
seller = atr_seller_factory(stop_times=600,trace_times=3000)

#开始计算
reload(srun)    #应对脚本修改
buyer = srun.prepare_buyer(dates)   
name,tradess = calc_trades(buyer,seller,sdata,dates,xbegin,cmediator=myMediator)
result,strade = ev.evaluate_all(tradess,pman,dman)

